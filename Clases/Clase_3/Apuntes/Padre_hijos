# ðŸ“Œ Apunte sobre Procesos Padre e Hijo en Python

## ðŸ”¹ Â¿QuÃ© es un proceso en Python?
Un **proceso** es un programa en ejecuciÃ³n. Cada proceso tiene un **PID (Process ID)** Ãºnico que lo identifica en el sistema.  

## ðŸ”¹ CreaciÃ³n de procesos: `os.fork()`
En Python, la funciÃ³n `os.fork()` se usa para **crear un nuevo proceso hijo**.  
Cuando se ejecuta:  
- Se **clona** el proceso actual.  
- Ambos procesos continÃºan ejecutÃ¡ndose desde la misma lÃ­nea.  
- `os.fork()` devuelve un valor diferente en cada proceso:  
  - **0** en el hijo (porque es el nuevo proceso).  
  - **PID del hijo** en el padre.  

### ðŸ”¹ Ejemplo bÃ¡sico de `os.fork()`
```python
import os

pid = os.fork()

if pid == 0:
    print(f"Soy el hijo, mi PID es {os.getpid()}, mi padre es {os.getppid()}")
else:
    print(f"Soy el padre, mi PID es {os.getpid()}, mi hijo es {pid}")
```
âœ… **El padre y el hijo ejecutan la misma lÃ­nea despuÃ©s de `os.fork()`.**  

---

## ðŸ”¹ Â¿CÃ³mo evitar que un padre tenga mÃ¡s de un hijo?
Si queremos que **el padre solo tenga un hijo a la vez**, podemos usar `os.wait()`, que hace que el padre espere a que su hijo termine antes de continuar:  

```python
import os

for i in range(5):
    pid = os.fork()

    if pid == 0:
        print(f"Soy el hijo {i + 1}, mi PID es {os.getpid()}, mi padre es {os.getppid()}")
        os._exit(0)  # El hijo termina
    else:
        os.wait()  # El padre espera a que el hijo termine antes de seguir

print(f"Soy el padre, mi PID es {os.getpid()}, terminÃ© de crear hijos")
```
âœ… **Este cÃ³digo asegura que el padre solo tenga un hijo a la vez.**  

---

## ðŸ”¹ Â¿QuÃ© pasa si el padre termina antes que el hijo? (Hijos huÃ©rfanos)
Si el proceso padre **termina antes que sus hijos**, estos se vuelven **huÃ©rfanos** y son adoptados por el proceso con PID 1 (`init`).  

```python
import os
import time

pid = os.fork()

if pid == 0:
    time.sleep(2)  # El hijo sigue vivo
    print(f"Soy el hijo, mi PID es {os.getpid()}, mi padre es ahora {os.getppid()}")
else:
    print("Soy el padre y termino antes que mi hijo")
    os._exit(0)  # El padre termina antes
```
âœ… **Cuando el padre termina, el `PPID` del hijo cambia a `1` (el proceso `init`).**  

---

## ðŸ”¹ Â¿QuÃ© pasa si el hijo termina antes que el padre? (Zombies)
Si un hijo termina pero el padre **no lo espera con `os.wait()`**, el hijo se convierte en un **proceso zombie** hasta que el padre recoge su estado.  

```python
import os
import time

pid = os.fork()

if pid == 0:
    print(f"Soy el hijo, mi PID es {os.getpid()} y termino rÃ¡pido")
    os._exit(0)
    
time.sleep(5)  # El padre sigue vivo sin llamar a wait()
print(f"Soy el padre, mi PID es {os.getpid()}")
```
âœ… **El hijo termina rÃ¡pido, pero el padre no lo "recoge", por lo que queda como zombie.**  

---

## ðŸ”¹ Resumen Final
| SituaciÃ³n | DescripciÃ³n | Ejemplo |
|-----------|------------|---------|
| **Hijos controlados** | El padre espera a cada hijo con `os.wait()` | âœ… No hay huÃ©rfanos ni zombies |
| **Hijos huÃ©rfanos** | El padre termina antes que los hijos | ðŸ”¸ `PPID` del hijo cambia a `1` |
| **Procesos zombie** | El hijo termina antes y el padre no usa `wait()` | ðŸ”¸ El proceso queda en la tabla de procesos hasta que el padre lo recoja |

---

### ðŸ“Œ **ConclusiÃ³n**
Los procesos en Python permiten la ejecuciÃ³n simultÃ¡nea de tareas.  
Saber cÃ³mo manejarlos correctamente **evita problemas como procesos huÃ©rfanos y zombies**.  

**ðŸ”¹ `os.fork()` crea procesos**  
**ðŸ”¹ `os.wait()` evita zombies**  
**ðŸ”¹ Padre e hijo: Un proceso padre puede gestionar cuÃ¡ntos hijos tiene y cuÃ¡ndo crea nuevos.**  
```