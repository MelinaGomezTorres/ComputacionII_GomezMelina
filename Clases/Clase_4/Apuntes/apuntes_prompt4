## üß† Apunte: **Pipes en Comunicaci√≥n entre Procesos ‚Äî Teor√≠a y Pr√°ctica con Python**

### üìå ¬øQu√© son los Pipes?

Los *pipes* (o "tuber√≠as") son una forma de comunicaci√≥n entre procesos (*InterProcess Communication*, IPC) usada ampliamente en sistemas UNIX/Linux. Funcionan como canales unidireccionales donde los datos fluyen de un proceso a otro en orden FIFO (First In, First Out).

> Fueron introducidos en 1973 por Ken Thompson, inspirado por una idea de Doug McIlroy, marcando el inicio de la **filosof√≠a UNIX**: *programas peque√±os, que hacen una sola cosa bien, combinables entre s√≠*.

---

### ‚öôÔ∏è Estructura Interna de un Pipe

Un pipe es m√°s que un simple canal. Internamente involucra:

- Un **buffer circular** en el espacio del kernel.
- **Punteros de lectura y escritura**, que mantienen el orden FIFO.
- **Descriptores de archivo** (uno para lectura, otro para escritura).
- Mecanismos de **sincronizaci√≥n** y **estado** que bloquean o despiertan procesos seg√∫n el flujo de datos.

---

### üîÅ Ciclo de Vida de un Pipe

1. **Creaci√≥n:** `os.pipe()` ‚Üí retorna dos descriptores (lectura y escritura).
2. **Fork():** Se duplica el proceso y ambos heredan los descriptores.
3. **Cierre de extremos no usados:** Cada proceso cierra lo que no necesita (evita bloqueos y fugas).
4. **Comunicaci√≥n:** Se realiza con `os.read()` y `os.write()` desde los extremos del pipe.
5. **Cierre final:** Cuando ambos extremos se cierran, el kernel libera los recursos.

---

### üß™ Implementaci√≥n en Python

A continuaci√≥n se muestra un ejemplo funcional que demuestra c√≥mo un proceso padre y su hijo se comunican usando `os.pipe()` y `os.fork()`.  
El padre env√≠a operaciones matem√°ticas y el hijo responde con el resultado.

```python
import os
import sys

def main():
    p2c_r, p2c_w = os.pipe()  # Padre a hijo
    c2p_r, c2p_w = os.pipe()  # Hijo a padre

    pid = os.fork()

    if pid > 0:
        # Proceso padre
        os.close(p2c_r)
        os.close(c2p_w)

        while True:
            operation = input("Ingrese una operaci√≥n matem√°tica (o 'salir' para terminar): ")
            os.write(p2c_w, (operation + "\n").encode())

            if operation.lower() == "salir":
                break

            response = os.read(c2p_r, 1024).decode()
            print(f"Padre recibi√≥:\n{response}")

        os.close(p2c_w)
        os.close(c2p_r)
        os.waitpid(pid, 0)

    else:
        # Proceso hijo
        os.close(p2c_w)
        os.close(c2p_r)

        while True:
            operation = b""
            while not operation.endswith(b"\n"):
                chunk = os.read(p2c_r, 1)
                if not chunk:
                    break
                operation += chunk

            operation = operation.decode().strip()
            if operation.lower() == "salir" or not operation:
                break

            try:
                result = str(eval(operation))
                status = "Operaci√≥n completada correctamente"
            except Exception as e:
                result = f"Error: {e}"
                status = "Operaci√≥n fallida"

            full_response = f"Resultado: {result}\nEstado: {status}"
            os.write(c2p_w, full_response.encode())

        os.close(p2c_r)
        os.close(c2p_w)
        sys.exit(0)

if __name__ == "__main__":
    main()
```

---

### ‚úÖ Estrategias para Prevenir Problemas Comunes

| Problema | Estrategia Aplicada |
|---------|---------------------|
| **Bloqueo mutuo (deadlock)** | Cada proceso cierra los extremos del pipe que no usa. |
| **Procesos zombie** | Uso de `os.waitpid()` para recolectar al hijo. |
| **Fugas de recursos** | Se cierran todos los descriptores al terminar. |
| **Lecturas incompletas** | Se lee hasta detectar un `\n`, asegurando mensajes completos. |
| **Evaluaci√≥n insegura** | El uso de `try-except` en `eval()` evita que errores de sintaxis interrumpan el flujo. |

---

### üìà Aplicaciones Comunes

- **Shell UNIX**: El operador `|` (pipe) conecta procesos como `ls | grep .py`.
- **Pipelines personalizados**: Dise√±os de procesamiento en cadena (output de uno ‚Üí input de otro).
- **Procesos concurrentes y multiproceso**: Comunicaci√≥n sencilla sin necesidad de sockets ni archivos temporales.

---

### üß≠ Conclusi√≥n

El uso de pipes permite implementar sistemas modulares, eficientes y f√°cilmente depurables.  
Este ejemplo en Python ilustra c√≥mo la teor√≠a de los pipes se traduce directamente en una implementaci√≥n pr√°ctica robusta, aplicando estrategias de prevenci√≥n de errores comunes.

